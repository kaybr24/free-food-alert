from flask import (Flask, render_template, make_response, url_for, request,
                   redirect, flash, session, send_from_directory, jsonify)
from apscheduler.schedulers.background import BackgroundScheduler
from werkzeug.utils import secure_filename
app = Flask(__name__)

# one or the other of these. Defaults to MySQL (PyMySQL)
# change comment characters to switch to SQLite

import cs304dbi as dbi
# import cs304dbi_sqlite3 as dbi

import random
import search
import helper
import insert
import profile
import register
import bcrypt
import information
from datetime import datetime, timedelta

# Initialize the scheduler for deleting the expired post
scheduler = BackgroundScheduler()

app.secret_key = 'your secret here'
# replace that with a random key
app.secret_key = ''.join([ random.choice(('ABCDEFGHIJKLMNOPQRSTUVXYZ' +
                                          'abcdefghijklmnopqrstuvxyz' +
                                          '0123456789'))
                           for i in range(20) ])

# This gets us better error messages for certain common request errors
app.config['TRAP_BAD_REQUEST_ERRORS'] = True


@app.route('/')
def index(): 
    conn = dbi.connect()
    helper.remove_expired_posts(conn)
    all_posts = helper.display_posts(conn)
    ratings = helper.find_guide_ratings(conn)

    comments = {}
    for post in all_posts:
        post_id = post.get('post_id')
        if post_id:
            post_comments = helper.get_comments_for_post(conn, post_id)
            comments[post_id] = post_comments
    print("!!!!!!!!!!!!!!!!!!!!!")
    print(comments)
    ## create time since posted tags
    for post in all_posts:
        if 'post_date' in post:
            #date_posted = datetime.strptime(post['post_date'], '%y-%m-%d %H:%M:%S')
            post['age'] = helper.find_post_age(post['post_date'])
        else:
            post['age'] = ''
    # customize page based on login status
    if not session.get('logged_in', False): # if not logged in
        session['logged_in'] = False
    print('**********************************')
    for key in session:
        print(key, session.get(key))
    return render_template('main.html',title='Free Food Alert', comments = comments, search_results=all_posts, ratedGuides=ratings, cookie=session)

@app.route('/rate-post/', methods=['GET', 'POST'])
def rate_post():
    """
    handle rating posts
    TO-DO: make this into Ajax embedded in homepage
    """
    if request.method == 'POST':
        data=request.form
        dbi.conf('wffa_db')
        conn = dbi.connect()
        # check if they are rating themselves
        if data.get('guide') == data.get('user'):
            flash(f"You can not rate yourself")
            return redirect(url_for('index'))
        else:
            helper.insert_rating(conn, data)
            flash(f"You rated {data.get('guide')}'s post {data.get('stars')} out of 5 stars")
            return redirect(url_for('index'))
    else: # request.method == 'GET':
        # go back
        return redirect(url_for('index'))

@app.route('/search/', methods = ['GET', 'POST'])
def search_posts():
    '''
    Handles searching of posts based on specified search criteria
    '''
    locations = information.locations
    if not session.get('logged_in', False): # if not logged in
        session['logged_in'] = False
    possible_allergens = information.possible_allergens

    if request.method == 'POST':
        building = request.form.getlist('building')
        allergens = request.form.getlist('allergens')
        date_posted = request.form['date_posted']

        search_information = {'building': building, 
                                'allergens': allergens,
                                'date_posted': date_posted}
        conn = dbi.connect()
        data = search.search_for_post(conn, search_information)
        return render_template('search_results.html', title='Matching Food Posts', cookie=session, data=data)
    return render_template('search_form.html', title='Filter Food Posts', cookie=session, locations=locations, possible_allergens=possible_allergens)


@app.route('/insert', methods=['GET', 'POST'])
def new_post():
    '''
    Create a new post with given information
    '''
    if not session.get('logged_in', False): # if not logged in
        session['logged_in'] = False
        flash("You must be logged in to access this page")
        return redirect(url_for('user_profile'))
    conn = dbi.connect()
    user_email = session.get('username')
    user_information = profile.get_user_info(conn, user_email)
    food_guide_status = user_information['food_guide']

    if food_guide_status != 1:
        flash("Please become a food guide ")
        return redirect(url_for('user_profile'))

    if request.method == 'POST':

        # Handle optional image upload
        food_image = request.files['food_image'] if 'food_image' in request.files else None

        # Insert into the database
        post_date = datetime.now()
        conn1 = dbi.connect()
        insert.insert_post(conn1, post_date, request.form)
        # insert.insert_post(conn, user_email, food_description, post_date, expiration_date, room_number, building, allergens)
        # insert.insert_post(conn, user_email, food_name, food_description, post_date, allergens, expiration_date, building, room_number)
        conn2 = dbi.connect()
        all_posts = helper.display_posts(conn2)

        conn3 = dbi.connect()
        insert.update_user_post_count(conn3, user_email)

        # Redirect to a success page or any other page
        return redirect(url_for('index'))

    # Render the form template for GET requests
    return render_template('new_post_form.html', title='Insert New Food Posting', cookie=session, possible_allergens=information.possible_allergens)

@app.route('/registration', methods=['GET', 'POST'])
def registration():
    '''
    Register a new user and update the database
    '''
    if request.method == 'POST':
        # Retrieve form data
        first_name = request.form['first_name']
        last_name = request.form['last_name']
        full_wellesley_email = request.form['wellesley_email']
        wellesley_email = full_wellesley_email.split('@')[0]
        password = request.form['password']
        confirm_password = request.form['confirm_password']
        terms_checkbox = request.form.get('terms_checkbox')
        full_name = request.form['full_name']
        date = request.form['date']

        #deal with password encrypting
        hashed = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())
        stored = hashed.decode('utf-8')

        # Check if the password and confirm_password match
        if password != confirm_password:
            flash('Passwords do not match')
            return render_template('register_form.html', title='Register as a User', cookie=session, error='Passwords do not match')

        # Check if the terms and conditions checkbox is checked
        if not terms_checkbox:
            flash('Please agree to the terms and conditions')
            return render_template('register_form.html', title='Register as a User', cookie=session, error='Please agree to the terms and conditions')
        
        # Check if user exists
        conn1=dbi.connect()
        existing_user = register.check_user_exists(conn1, wellesley_email)
        if existing_user:
            flash('User already exists. Please login.')
            return render_template('register_form.html', title='Register as a User', cookie=session, error='User already exists. Please login.')
        
        conn2=dbi.connect()
        result = register.register_user(conn2, full_name, wellesley_email, hashed, date)
        if result:
            # Redirect to a success page or (currently) login page
            flash(f"Registered user {wellesley_email}")
            session['username'] = wellesley_email
            session['uid'] = wellesley_email
            session['logged_in'] = True
            session['visits'] = 1
            return redirect(url_for('index'))
        else:
            flash("Registration failed. Please try again.")
            return render_template('register_form.html', title='Register as a User', cookie=session, error='Registration failed. Please try again.') # where should this show?

    else:
        # Render the registration form for GET requests
        return render_template('register_form.html', title='Register as a User', cookie=session, error=None)

"""
Lets users become food guides (ie, food guide column for user becomes a 1)
"""
@app.route('/become_food_guide', methods=['POST'])
def become_food_guide():
    '''
    Allow a user to become a food guide and make posts.
    '''
    # Get the user's email from the session
    user_email = session.get('username')
    print(user_email)
    if not user_email:
        #user isn't logged in
        return redirect(url_for('login'))  # Redirect to login page

    # Update the user's food_guide status in the database
    conn = dbi.connect()
    profile.update_food_guide_status(conn, user_email)

    return redirect(url_for('user_profile'))


@app.route('/user_profile')
def user_profile():
    '''
    Gets user information for a profile page
    '''
    #get user email from session
    user_email = session.get('username')

    if not user_email: #not logged in
        return redirect(url_for('login'))

    # Get user data from the database (replace with your logic)
    conn = dbi.connect()
    user_data = profile.get_user_info(conn, user_email)

    if not user_data:
        return "User not found."

    return render_template('profile.html', title='View Profile', cookie=session, user=user_data)



@app.route('/login', methods=['GET', 'POST'])
def login():
    '''
    Allows users to login to the website.
    '''
    if request.method == 'POST':
        user_email = request.form['user_email']
        password = request.form['password']

        # Validate user 
        conn = dbi.connect()
        user_info = profile.validate_user(conn, user_email, password)
        if user_info: # the user exists
            # Set user_email in the session
            # session['user_email'] = user_email
            stored = user_info['password']
            hashed2 = bcrypt.hashpw(password.encode('utf-8'),
                            stored.encode('utf-8'))
            hashed2_str = hashed2.decode('utf-8')
            if hashed2_str == stored:
                flash('successfully logged in as '+ user_email)
                session['username'] = user_email
                session['uid'] = user_info['user_email']
                session['logged_in'] = True
                session['visits'] = 1
                # Redirect to the user profile page
                return redirect( url_for('user_profile') )
            else:
                flash('login incorrect. Try again or join') #  incorrect password
                return redirect(url_for('index'))

        else: # incorrect username
            flash('login incorrect. Try again or join')
            return redirect(url_for('index'))
    else:
        # Render the login form for GET requests
        print("***************recieved GET login request")
        return render_template('login.html', title='Log Into Free Food Alert', cookie=session)

@app.route('/add_comment', methods=['POST'])
def add_comment():
    if request.method == 'POST':
        data = request.form
        print('data')
        print(data)
        post_id = data.get('post_id')
        user_email = session.get('username')
        comment_text = data.get('comment_text')

        if not post_id:
            flash("unable to comment")
            return redirect(url_for('index'))
        if not comment_text:
            flash('please provide comment text')
            return redirect(url_for('index'))
       
        # Insert the comment into the database
        conn = dbi.connect()
        helper.insert_comment(conn, post_id, user_email, comment_text)
        
        flash('Comment added successfully.')
        return redirect(url_for('index'))

@app.route('/logout')
def logout():
    session.clear()  # Clear all session variables
    flash('You have been logged out.')
    return redirect(url_for('index'))

# Remove expired posts every 24 hours
@scheduler.scheduled_job('interval', hours=24)
def remove_expired_posts_job():
    conn = dbi.connect()
    helper.remove_expired_posts(conn)
    print('Expired posts have been removed.')

# Start the scheduler
scheduler.start()

if __name__ == '__main__':
    import sys, os
    if len(sys.argv) > 1:
        # arg, if any, is the desired port number
        port = int(sys.argv[1])
        assert(port>1024)
    else:
        port = os.getuid()
    # set this local variable to 'wmdb' or your personal or team db
    db_to_use = 'wffa_db' 
    print('will connect to {}'.format(db_to_use))
    dbi.conf(db_to_use)
    app.debug = True
    app.run('0.0.0.0',port+1)
## some helper functions
import cs304dbi as dbi
from datetime import datetime, timedelta

def display_posts(conn):
    """
    returns a list of all active posts as dictionaries
    """
    curs = dbi.dict_cursor(conn)
    # atomic reads should be thread-safe
    curs.execute("""
        select `post_id`, `user_email`, `description`, `post_date`, 
        date(`expiration_date`) as 'expiration', `location`, `building`, `allergens`
        from post
        order by `post_date` desc;
    """)
    posts = curs.fetchall()
    return posts

def find_guide_ratings(conn, specific_guide=None):
    '''
    if no specific_guide is specified, returns a dictionary of [avgrating, count(ratings)] for each guide
    if a specific_guide is specified, returns a dictionary with one element (the rating, count pair for that guide)
    '''
    curs = dbi.dict_cursor(conn)
    rated_guides = {}
    if specific_guide:
        curs.execute("""select avg(rating), count(rating) from rating where guide_email like %s;""",
            [specific_guide])
        rating = curs.fetchone()
        rated_guides = {specific_guide: [float(rating.get('avg(rating)')), float(rating.get('count(rating)'))]}
    else:
        # atomic read should be thread-safe
        curs.execute("""select avg(rating), guide_email, count(rating)
            from rating 
            group by guide_email;
            """)
        rating = curs.fetchall()
        for guideDict in rating:
            guide = guideDict.get('guide_email')
            stars = guideDict.get('avg(rating)')
            count = guideDict.get('count(rating)')
            if stars:
                rated_guides[guide] = [float(stars), int(count)]
            # else:  
            #     rated_guides[guide] = [0, 0]
    return rated_guides

def insert_rating(conn, rating):
    """
    given the username, food guide and star rating as a dictionary, 
    insert the new rating into the database
    """
    curs = dbi.dict_cursor(conn)
    # atomic insert should be thread-safe
    query = """insert into rating(`post_id`, `guide_email`, `rater_email`, `rating`)
        values (%s, %s, %s, %s)
        on duplicate key update
        `rating` = %s;""" # change primary key so this works
    values = [
        rating.get('postID'), 
        rating.get('guide'),
        rating.get('user'),
        rating.get('stars'),
        rating.get('stars')
        ]
    curs.execute(query, values)
    conn.commit()

def find_post_age(post_date):
    """given the age of a post, return a (number, string) pair
    representing the age and time units of the post"""
    today = datetime.now()
    delta = today - post_date
    dpm = 7*52.143/12 # days per month
    if delta.days > dpm:
        if delta.days//dpm == 1:
            return ('1 month')
        else:
            return (str(int(delta.days//dpm)) +' months')
    elif delta.days > 7:
        if delta.days//7 == 1:
            return ('1 week')
        else:
            return (str(delta.days//7) +' weeks')
    elif delta.days > 0:
        if delta.days == 1:
            return ("1 day")
        else:
            return (str(delta.days) + ' days')
    elif delta.seconds > 3600:
        if delta.seconds//3600 == 1:
            return('1 hour')
        else:
            print(today, post_date, delta.seconds/3600)
            return (str(delta.seconds//3600) + ' hours')
    elif delta.seconds > 60:
        if delta.seconds//60 == 1:
            return('1 minute')
        else:
            return (str(delta.seconds//60) + ' minutes')
    else:
        if delta.seconds == 1:
            return ('1 second')
        else:
            return (str(delta.seconds) + ' seconds')

def remove_expired_posts(conn):
    """
    Remove expired posts from the database.
    """
    curs = dbi.dict_cursor(conn)
    current_date = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    query = """
        DELETE FROM post
        WHERE expiration_date < %s
    """
    #curs.execute("DELETE FROM rating WHERE post_id IN (SELECT post_id FROM post WHERE expiration_date < %s)", (current_date,))
    # atomic delete should be thread-safe
    curs.execute(query, [current_date])
    conn.commit()
    
def insert_comment(conn, post_id, user_email, comment):
    '''
    Inserts comment to a post into table
    '''
    curs = dbi.dict_cursor(conn)
    now = datetime.now()
    commentDate = now.strftime('%Y-%m-%d %H:%M:%S')
    # atomic insert should be thread-safe
    curs.execute('''insert into comments(post_id, user_email, comment, date)
                    values(%s, %s, %s, %s)''',
                    [post_id, user_email, comment, commentDate])

    # query = "INSERT INTO comments (post_id, user_email, comment, date) VALUES ((%s, %s, %s, %s)"
    # values=[post_id, user_email, comment, commentDate]
    # curs.execute(query, values)
    conn.commit()

def get_comments_for_post(conn, post_id):
    '''
    gets the comments for a post
    '''
    curs = dbi.dict_cursor(conn)
    # atomic read should be thread-safe
    query = "SELECT * FROM comments WHERE post_id=%s ORDER BY date DESC"
    curs.execute(query, [post_id])
    return curs.fetchall()



if __name__ == '__main__':
    db_to_use = 'wffa_db' 
    print('will connect to {}'.format(db_to_use))
    dbi.conf(db_to_use)
    conn = dbi.connect()
    # testing find_post_age()
    time = datetime(2023, 10, 23)
    print(find_post_age(time))
    # testing find_guide_ratings()
    print(find_guide_ratings(conn))
    print(find_guide_ratings(conn, 'kb102'))
    #print(display_posts(conn))import cs304dbi as dbi

def insert_post(conn, post_date, information):
    curs = dbi.dict_cursor(conn)
    full_user_email = information['user_email']
    user_email = full_user_email.split('@')[0]
    # food_name = information['food_name']
    food_description = information['food_description']
    allergens = information.getlist('allergens')
    
    expiration_date = information['expiration_date']
    building = information['building_dropdown']
    room_number = information['room_number']


    curs.execute('''insert into post(user_email, description, post_date, expiration_date, location, building, allergens)
                    values(%s, %s, %s, %s, %s, %s, %s)''',
                    [user_email, food_description, post_date, expiration_date, room_number, building, ','.join(allergens)])
    conn.commit()

def update_user_post_count(conn, user_email):
    curs = conn.cursor()
    query = "SELECT COUNT(*) FROM post WHERE user_email=%s"
    curs.execute(query, (user_email,))
    posts = curs.fetchone()[0]

    update_post_count = "UPDATE user SET post_count = %s where user_email = %s"
    curs.execute(update_post_count, (posts, user_email))

    conn.commit()import cs304dbi as dbi

def update_food_guide_status(conn, user_email):
    curs = dbi.dict_cursor(conn)
    # Update the user's food_guide status to 1
    curs.execute("UPDATE user SET food_guide = 1 WHERE user_email = %s", [user_email])
    conn.commit()

def get_user_info(conn, user_email):
    curs = dbi.dict_cursor(conn)
    curs.execute("SELECT * FROM user WHERE user_email = %s", [user_email])
    user_data = curs.fetchone()
    return user_data

def validate_user(conn, user_email, password):
    curs = dbi.dict_cursor(conn)
    curs.execute('''SELECT user_email, password
                    from user where user_email = %s''', [user_email])
    user = curs.fetchone()
    return user

# if __name__ == '__main__':
#     db_to_use = 'wffa_db' 
#     print('will connect to {}'.format(db_to_use))
#     dbi.conf(db_to_use)
#     conn = dbi.connect()
#     result = validate_user(conn, 'rd100', '')
#     print(result)
#     if None:
#         print("None is true")
#     elif result:
#         print("dictionary is true")
#     else:
#         print("Only True is true")#Kayley's search file with queries 
import cs304dbi as dbi
from datetime import datetime

legalAllergens =['soy', 'peanuts', 'dairy', 'gluten', 'eggs', 'shellfish', 'nuts', 'sesame']
legalBuildings = ['Acorns', 'Alumnae Hall', 'Athletic Maintenance Facility', 'Bates Hall', 
    'Beebe Hall', 'Billings', 'Boathouse', 'Campus Police Headquarters', 'Cazenove Hall', 
    'Cedar Lodge', 'Cervantes', 'Cheever House', 'Child Study Center', 'Claflin Hall', 
    'Collins Cinema', 'Continuing Education Office', 'Davis Hall', 'Davis Museum', 
    'Davis Parking Facility', 'Day Care Center', 'Distribution Center', 'Dower House', 
    'East Lodge', 'Fiske House', 'Founders Hall', 'Freeman Hall', 'French House - Carriage', 
    'French House - Main', 'Golf House', 'Green Hall', 'Grounds', 'Hallowell House', 'Harambee House', 
    'Hemlock', 'Homestead', 'Horton House', 'Instead', 'Jewett Art Center', 'Keohane Sports Center', 
    'Lake House', 'Library', 'Lulu Chow Wang Campus Center', 'Margaret Ferguson Greenhouses', 
    'McAfee Hall', 'Motor Pool', 'Munger Hall', 'Nehoiden House', 'Observatory', 'Orchard Apts', 
    'Pendleton Hall East', 'Pendleton Hall West', 'Physical Plant', 'Pomeroy Hall', 
    "President's House", 'Ridgeway Apts', 'Schneider Center', 'Science Center', 'Service Building', 
    'Severance Hall', 'Shafer Hall', 'Shakespeare', 'Shepard House', 'Simpson Hall', 'Simpson West', 
    'Slater International Center', 'Stone Center', 'Stone Hall', 'Tower Court East', 'Tower Court West',
     'Trade Shops Building', 'Tau Zeta Epsilon', 'Waban House', 'Weaver House', 'Webber Cottage', 
     'Wellesley College Club', 'West Lodge', 'Whitin House', 'Zeta Alpha House']

def search_for_post(conn, searched_item):
    """
    Given a dictionary if items searched for by the user, 
    finds if there are any posts with specified search
    and returns the post.
    """
    curs = dbi.dict_cursor(conn)

    query = "SELECT * FROM post WHERE"

    if len(searched_item['building'])>0:
        l = searched_item['building']
        locations=tuple(x for x in l)
        for place in locations:
            if place not in legalBuildings: # data check against list of locations
                print(place)
                raise ValueError("illegal building")
                return None
        query += " building IN {}".format(locations).replace(',)', ')')
    

    if len(searched_item['allergens'])>0:
        allergens = tuple(searched_item['allergens'])
        print("**************************************************")
        print(allergens)
        if 'building' in query:
            query += " AND"
        for allergen in allergens:
            if allergen not in legalAllergens: # see if in subset of allergens
                raise ValueError('illegal allergen')
                return None
            if allergen != allergens[0]:
                query += " AND"
            query += " (allergens not like '%{}%')".format(allergen) # this allergen is not listed

    if searched_item['date_posted']:
        formatted_date = datetime.strptime(searched_item['date_posted'], '%Y-%m-%d').strftime('%Y-%m-%d')

        if 'building' in query or 'allergens' in query:
            query += " AND post_date = '{}'".format(formatted_date)
        else:
            query += " post_date = '{}'".format(formatted_date)
      
    if query == "SELECT * FROM post WHERE":
        query = "SELECT * from post"
        
    print(query)
    curs.execute(query)

    data = curs.fetchall()
    return data

if __name__ == '__main__':
    db_to_use = 'wffa_db' 
    print('will connect to {}'.format(db_to_use))
    dbi.conf(db_to_use)
    conn = dbi.connect()
    if ("Bates Hall", "Tupelo Pool") not in legalBuildings: # data check against list of locations
        print("success")
    print(
        ("Bates Hall") not in legalBuildings,
        ("Bates Hall", "Tupelo Pool") not in legalBuildings,
        ("Bates Hall", "Lulu Chow Wang Campus Center") not in legalBuildings,
        ("Bates Hall",) not in legalBuildings
    )

locations=['Acorns', 'Alumnae Hall', 'Athletic Maintenance Facility', 'Bates Hall', 'Beebe Hall', 'Billings', 'Boathouse', 
    'Campus Police Headquarters', 'Cazenove Hall','Cedar Lodge', 'Cervantes', 'Cheever House', 'Child Study Center', 'Claflin Hall', 
    'Collins Cinema', 'Continuing Education Office', 'Davis Hall', 'Davis Museum', 
    'Davis Parking Facility', 'Day Care Center', 'Distribution Center', 'Dower House', 
    'East Lodge', 'Fiske House', 'Founders Hall', 'Freeman Hall', 'French House - Carriage', 
    'French House - Main', 'Golf House', 'Green Hall', 'Grounds', 'Hallowell House', 'Harambee House', 
    'Hemlock', 'Homestead', 'Horton House', 'Instead', 'Jewett Art Center', 'Keohane Sports Center', 
    'Lake House', 'Library', 'Lulu Chow Wang Campus Center', 'Margaret Ferguson Greenhouses', 
    'McAfee Hall', 'Motor Pool', 'Munger Hall', 'Nehoiden House', 'Observatory', 'Orchard Apts', 
    'Pendleton Hall East', 'Pendleton Hall West', 'Physical Plant', 'Pomeroy Hall', 
    "President's House", 'Ridgeway Apts', 'Schneider Center', 'Science Center', 'Service Building', 
    'Severance Hall', 'Shafer Hall', 'Shakespeare', 'Shepard House', 'Simpson Hall', 'Simpson West', 
    'Slater International Center', 'Stone Center', 'Stone Hall', 'Tower Court East', 'Tower Court West',
    'Trade Shops Building', 'Tau Zeta Epsilon', 'Waban House', 'Weaver House', 'Webber Cottage', 
    'Wellesley College Club', 'West Lodge', 'Whitin House', 'Zeta Alpha House']
possible_allergens = ['Soy', 'Peanuts', 'Dairy', 'Eggs', 'Shellfish', 'Nuts', 'Sesame', 'Gluten']